{
  "name": "phridge",
  "version": "1.0.7",
  "description": "A bridge between node and phantomjs",
  "main": "./lib/main.js",
  "scripts": {
    "test": "node node_modules/mocha/bin/mocha -R spec",
    "coverage": "istanbul cover ./node_modules/mocha/bin/_mocha"
  },
  "keywords": [
    "phantom",
    "phantomjs",
    "bridge",
    "communication",
    "process",
    "subprocess",
    "long-term",
    "forever"
  ],
  "dependencies": {
    "fork-stream": "^0.0.4",
    "linerstream": "^0.1.4",
    "phantomjs": "^1.9.7-15",
    "temp": "^0.8.0",
    "when": "^3.4.2"
  },
  "devDependencies": {
    "chai": "^1.9.1",
    "chai-as-promised": "^4.1.1",
    "getport": "^0.1.0",
    "istanbul": "^0.3.0",
    "mocha": "^1.21.3"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/peerigon/phridge.git"
  },
  "author": {
    "name": "peerigon",
    "email": "developers@peerigon.com"
  },
  "license": "Unlicense",
  "readme": "phridge\r\n========================================================================\r\n**A bridge between [node](http://nodejs.org/) and [PhantomJS](http://phantomjs.org/).**\r\n\r\n[![Build Status](https://travis-ci.org/peerigon/phridge.svg?branch=master)](https://travis-ci.org/peerigon/phridge)\r\n[![Dependency Status](https://david-dm.org/peerigon/phridge.svg)](https://david-dm.org/peerigon/phridge)\r\n[![Coverage Status](https://img.shields.io/coveralls/peerigon/phridge.svg)](https://coveralls.io/r/peerigon/phridge?branch=master)\r\n\r\nWorking with PhantomJS in node is a bit cumbersome since you need to spawn a new PhantomJS process for every single task. However, spawning a new process is quite expensive and thus can slow down your application significantly.\r\n\r\n**phridge** provides an api to easily\r\n\r\n- spawn new PhantomJS processes\r\n- run functions with arguments inside PhantomJS\r\n- return results from PhantomJS to node\r\n- manage long-running PhantomJS instances\r\n\r\nUnlike other node-PhantomJS bridges **phridge** provides a way to run code directly inside PhantomJS instead of turning every call and assignment into an async operation.\r\n\r\n**phridge** uses PhantomJS' stdin and stdout for [inter-process communication](http://en.wikipedia.org/wiki/Inter-process_communication). It stringifies the given function, passes it to PhantomJS via stdin, executes it in the PhantomJS environment and passes back the results via stdout. Thus you can write your PhantomJS scripts inside your node modules in a clean and synchronous way.\r\n\r\nInstead of ...\r\n\r\n```javascript\r\nphantom.addCookie(\"cookie_name\", \"cookie_value\", \"localhost\", function () {\r\n    phantom.createPage(function () (page) {\r\n        page.set(\"customHeaders.Referer\", \"http://google.com\", function () {\r\n            page.set(\r\n                \"settings.userAgent\",\r\n                \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)\",\r\n                function () {\r\n                    page.open(\"http://localhost:9901/cookie\", function (status) {\r\n                        page.evaluate(function (selector) {\r\n                            return document.querySelector(selector).innerText;\r\n                        }, function (text) {\r\n                            console.log(\"The element contains the following text: \"+ text)\r\n                        }, \"h1\");\r\n                    });\r\n                }\r\n            );\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n... you can write ..\r\n\r\n```javascript\r\n// node\r\nphantom.run(\"h1\", function (selector, resolve) {\r\n    // this code runs inside PhantomJS\r\n\r\n    phantom.addCookie(\"cookie_name\", \"cookie_value\", \"localhost\");\r\n\r\n    var page = webpage.create();\r\n    page.customHeaders = {\r\n        Referer: \"http://google.com\"\r\n    };\r\n    page.settings = {\r\n        userAgent: \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)\"\r\n    };\r\n    page.open(\"http://www.google.com\", function () {\r\n        var text = page.evaluate(function (selector) {\r\n            return document.querySelector(selector).innerText;\r\n        }, selector);\r\n\r\n        // resolve the promise and pass 'text' back to node \r\n        resolve(text);\r\n    });\r\n}).then(function (text) {\r\n    // inside node again\r\n    console.log(\"The element contains the following text: \"+ text);\r\n});\r\n```\r\n\r\nPlease note that the `phantom`-object provided by **phridge** is completely different to the `phantom`-object inside PhantomJS. So is the `page`-object. [Check out the api](#api-phantom) for further information.\r\n\r\nSince communication via stdin/stdout is always asynchronous **phridge** returns promises most of the time. It uses [when.js](https://github.com/cujojs/when) which is Promises/A+ compliant, so using your favorite promise library should be no problem.\r\n\r\n<br />\r\n\r\nInstallation\r\n------------------------------------------------------------------------\r\n\r\n[![npm status](https://nodei.co/npm/phridge.png?downloads=true&stars=true)](https://npmjs.org/package/phridge)\r\n\r\n<br />\r\n\r\nExamples\r\n------------------------------------------------------------------------\r\n\r\nThe following examples are using [when.js](https://github.com/cujojs/when) but you should be free to use any Promises/A+ compliant library.\r\n\r\n### Spawn a new PhantomJS process\r\n\r\n```javascript\r\nphridge.spawn({\r\n    proxyAuth: \"john:1234\",\r\n    loadImages: false\r\n}).then(function (phantom) {\r\n    // phantom is now a reference to a specific PhantomJS process\r\n});\r\n```\r\n\r\n`phridge.spawn()` takes an object which will be passed as config to PhantomJS. [Check out their documentation](http://phantomjs.org/api/command-line.html) for a detailed overview of options. Use camelCase style for option names of course.\r\n\r\n### Run any function inside PhantomJS\r\n\r\n```javascript\r\nphantom.run(function () {\r\n    console.log(\"Hi from PhantomJS\");\r\n});\r\n```\r\n\r\n**phridge** stringifies the given function, sends it to PhantomJS and evals it again. Hence you can't use scope variables:\r\n\r\n```javascript\r\nvar someVar = \"hi\";\r\n\r\nphantom.run(function () {\r\n    console.log(someVar); // throws a ReferenceError\r\n});\r\n```\r\n\r\n### Passing arguments\r\n\r\nYou can also pass arguments to the PhantomJS process:\r\n\r\n```javascript\r\nphantom.run(\"1\", 2, {}, function (string, number, object) {\r\n    console.log(string, number, object); // '1', 2, [object Object]\r\n});\r\n```\r\n\r\nArguments are stringified by `JSON.stringify()` so be sure to use JSON-valid objects.\r\n\r\n### Returning results\r\n\r\nThe given function can run sync and async. However, the `run()` method itself will always run async as it needs to wait for the http response.\r\n\r\n**Sync**\r\n\r\n```javascript\r\nphantom.run(function () {\r\n    return Math.PI;\r\n}).then(function (pi) {\r\n    console.log(pi === Math.PI); // true\r\n});\r\n```\r\n\r\n**Async**\r\n\r\n```javascript\r\nphantom.run(function (resolve) {\r\n    setTimeout(function () {\r\n        resolve(\"after 500 ms\");\r\n    }, 500);\r\n}).then(function (msg) {\r\n    console.log(msg); // 'after 500 ms'\r\n});\r\n```\r\n\r\n### Returning errors\r\n\r\nErrors can be returned by using the `throw` keyword or by calling the `reject`-function. Both ways will reject the promise returned by `run()`.\r\n\r\n**Sync**\r\n\r\n```javascript\r\nphantom.run(function () {\r\n    throw new Error(\"An unknown error occured\");\r\n}).catch(function (err) {\r\n    console.log(err); // 'An unknown error occured'\r\n});\r\n```\r\n\r\n**Async**\r\n\r\n```javascript\r\nphantom.run(function (resolve, reject) {\r\n    setTimeout(function () {\r\n        reject(new Error(\"An unknown error occured\"));\r\n    }, 500);\r\n}).catch(function (err) {\r\n    console.log(err); // 'An unknown error occured'\r\n});\r\n```\r\n\r\n### Async methods with arguments\r\n\r\n`resolve` and `reject` are just appended to the regular arguments:\r\n\r\n```javascript\r\nphantom.run(1, 2, 3, function (one, two, three, resolve, reject) {\r\n\r\n});\r\n```\r\n\r\n### Persisting states inside PhantomJS\r\n\r\nSince the function passed to `phantom.run()` can't declare variables in the global scope, it is impossible to maintain state in PhantomJS. That's why `phantom.run()` calls all functions on the same context object. Thus you can easily store state variables.\r\n\r\n```javascript\r\nphantom.run(function () {\r\n    this.message = \"Hello from the first call\";\r\n}).then(function () {\r\n    phantom.run(function () {\r\n        console.log(this.message); // 'Hello from the first call'\r\n    });\r\n});\r\n```\r\n\r\nFor further convenience all PhantomJS modules are already available in the global scope.\r\n\r\n```javascript\r\nphantom.run(function () {\r\n    console.log(webpage);           // [object Object]\r\n    console.log(system);            // [object Object]\r\n    console.log(fs);                // [object Object]\r\n    console.log(webserver);         // [object Object]\r\n    console.log(child_process);     // [object Object]\r\n});\r\n```\r\n\r\n### Working in a page context\r\n\r\nMost of the time its more useful to work in a specific webpage context. This is done by creating a Page via `phantom.createPage()` which calls internally `require(\"webpage\").create()`. The returned page wrapper will then execute all functions bound to a PhantomJS [webpage instance](http://phantomjs.org/api/webpage/). \r\n\r\n```javascript\r\nvar page = phantom.createPage();\r\n\r\npage.run(function (resolve, reject) {\r\n    // `this` is now a webpage instance\r\n    this.open(\"http://example.com\", function (status) {\r\n        if (status !== \"success\") {\r\n            return reject(new Error(\"Cannot load \" + this.url));\r\n        }\r\n        resolve();\r\n    });\r\n});\r\n```\r\n\r\nAnd for the busy ones: You can just call `phantom.openPage(url)` which is basically the same as above:\r\n\r\n```javascript\r\nphantom.openPage(\"http://example.com\").then(function (page) {\r\n    console.log(\"Example loaded\");\r\n};\r\n``` \r\n\r\n### Cleaning up\r\n\r\nIf you don't need a particular page anymore, just call:\r\n\r\n```javascript\r\npage.dispose().then(function () {\r\n    console.log(\"page disposed\");\r\n});\r\n```\r\n\r\nThis will clean up all page references inside PhantomJS.\r\n\r\nIf you don't need the whole process anymore call\r\n\r\n```javascript\r\nphantom.dispose().then(function () {\r\n    console.log(\"process terminated\");\r\n});\r\n```\r\n\r\nwhich will terminate the process cleanly by calling `phantom.exit(0)` internally. You don't need to dispose all pages manuallly when you call `phantom.dispose()`.\r\n\r\nHowever, calling\r\n\r\n```javascript\r\nphridge.disposeAll().then(function () {\r\n    console.log(\"All processes created by phridge.spawn() have been terminated\");\r\n});\r\n```\r\n\r\nwill terminate all processes.\r\n\r\n**I strongly recommend to call** `phridge.disposeAll()` **when the node process exits as this is the only way to ensure that all child processes terminate as well.** Since `disposeAll()` is async it is not safe to call it on `process.on(\"exit\")`. It is better to call it on `SIGINT`, `SIGTERM` and within your regular exit flow.\r\n\r\n<br />\r\n\r\nAPI\r\n------------------------------------------------------------------------\r\n### phridge\r\n\r\n### .spawn(config?): Promise → Phantom\r\n\r\nSpawns a new PhantomJS process with the given config. [Read the PhantomJS documentation](http://phantomjs.org/api/command-line.html) for all available config options. Use camelCase style for option names. The promise will be fulfilled with an instance of `Phantom`.\r\n\r\n### .disposeAll(): Promise\r\n\r\nTerminates all PhantomJS processes that have been spawned. The promise will be fulfilled when all child processes emitted an `exit`-event.\r\n\r\n### .config.stdout: Stream = process.stdout\r\n\r\nDestination stream where PhantomJS' [clean stdout](#phantom-childprocess-cleanstdout) will be piped to. Set it `null` if you don't want it. Changing the value does not affect processes that have already been spawned.\r\n\r\n### .config.stderr: Stream = process.stderr\r\n\r\nDestination stream where PhantomJS' stderr will be piped to. Set it `null` if you don't want it. Changing the value does not affect processes that have already been spawned.\r\n\r\n----\r\n\r\n### <a name=\"api-phantom\"></a>Phantom (instance)\r\n\r\n### .childProcess: ChildProcess\r\n\r\nA reference to the [ChildProcess](http://nodejs.org/api/child_process.html#child_process_class_childprocess)-instance.\r\n\r\n### <a name=\"phantom-childprocess-cleanstdout\"></a> .childProcess.cleanStdout: ReadableStream\r\n\r\nphridge extends the [ChildProcess](http://nodejs.org/api/child_process.html#child_process_class_childprocess)-instance by a new stream called `cleanStdout`. This stream is piped to `process.stdout` by default. It provides all data not dedicated to phridge. Streaming data is considered to be dedicated to phridge when the new line is preceded by the classifier string `\"message to node: \"`.\r\n\r\n### <a name=\"phantom-run\"></a>.run(args..., fn): Promise → *\r\n\r\nStringifies `fn`, sends it to PhantomJS and executes it there again. `args...` are stringified using `JSON.stringify()` and passed to `fn` again. `fn` may simply `return` a result or `throw` an error or call `resolve()` or `reject()` respectively if it is asynchronous. **phridge** compares `fn.length` with the given number of arguments to determine whether `fn` is sync or async. The returned promise will be resolved with the result or rejected with the error.\r\n\r\n### .createPage(): Page\r\n\r\nCreates a wrapper to execute code in the context of a specific [PhantomJS webpage](http://phantomjs.org/api/webpage/).\r\n\r\n### .openPage(url): Promise → Page\r\n\r\nCalls `phantom.createPage()`, then `page.open(url, cb)` inside PhantomJS and resolves when `cb` is called. If the returned `status` is not `\"success\"` the promise will be rejected.\r\n\r\n### .dispose(): Promise\r\n\r\nCalls `phantom.exit(0)` inside PhantomJS and resolves when the child process emits an `exit`-event.\r\n\r\n---\r\n\r\n### Page (instance)\r\n\r\n### .phantom: Phantom\r\n\r\nA reference to the parent [`Phantom`](#api-phantom) instance.\r\n\r\n### .run(args..., fn): Promise → *\r\n\r\nCalls `fn` on the context of a PhantomJS page object. See [`phantom.run()`](#phantom-run) for further information.\r\n\r\n### .dispose(): Promise\r\n\r\nCleans up all page references inside PhantomJS.\r\n\r\n<br />\r\n\r\nContributing\r\n------------------------------------------------------------------------\r\n\r\nFrom opening a bug report to creating a pull request: **every contribution is appreciated and welcome**. If you're planing to implement a new feature or change the api please create an issue first. This way we can ensure that your precious work is not in vain.\r\n\r\nAll pull requests should have 100% test coverage (with notable exceptions) and need to pass all tests.\r\n\r\n- Call `npm test` to run the unit tests\r\n- Call `npm run coverage` to check the test coverage (using [istanbul](https://github.com/gotwarlost/istanbul))  \r\n\r\n<br />\r\n\r\nLicense\r\n------------------------------------------------------------------------\r\n\r\nUnlicense\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/peerigon/phridge/issues"
  },
  "homepage": "https://github.com/peerigon/phridge",
  "_id": "phridge@1.0.7",
  "dist": {
    "shasum": "2a7add4700427992ef497508396cf463a9a9395e"
  },
  "_from": "phridge@~1.0.7",
  "_resolved": "https://registry.npmjs.org/phridge/-/phridge-1.0.7.tgz"
}
